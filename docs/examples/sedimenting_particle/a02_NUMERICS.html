<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>modelling-microplastics-transport.examples.sedimenting_particle.a02_NUMERICS API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>modelling-microplastics-transport.examples.sedimenting_particle.a02_NUMERICS</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys
sys.path.append(&#39;/home/s2182576/Documents/academia/thesis/&#39;
                                + &#39;modelling-microplastics-transport/examples/&#39;
                                + &#39;sedimenting_particle&#39;)
import numpy as np
import multiprocessing as mp
import pandas as pd
from progressbar import progressbar

from a03_FIELD0_QUIESCENT import QuiescentFlow
from a09_PRTCLE_FOKAS import MaxeyRileyFokas

def main():
        &#34;&#34;&#34;
        Produces numerical solutions for a particle&#39;s motion in a fluid flow.

        Notes
        -----
        - Based on work by author cfg4065.
        - The nonlinear solving process may not converge if two consecutive time
          nodes are too close to each other (for example if a large amount of nodes 
          is provided). This could be addressed by either (1) changing the 
          nonlinear solver, (2) increasing the number of maximum iterations or (3) 
          decreasing the tolerance. These parameters can be changed in the 
          `a09_PRTCLE_FOKAS script`, under the `update` method.
        - The velocity field is defined in the `a03_FIELD0_QUIESCENT` file, whose
          class is imported.
        - Changing the parameters related to the time grid, i.e. `tini`, `tend`,
          `nt`, may require a recalculation of the matrix values to ensure
          convergence of the nonlinear solver (automatically done by the ToolBox by 
          deleting the `a00_MATRX_VALUES.txt` file).
        &#34;&#34;&#34;
        # Define time grid
        tini = 0.0      # Initial time
        tend = 10.0     # Final time
        nt = 6
        #nt = 351       # Time nodes, delta t approx 0.03
        #nt = 2327      # Time nodes, delta t approx 0.0043

        # Create time axis, where S = 0.01
        taxis  = np.linspace(tini, tend, nt)
        dt = taxis[1] - taxis[0]

        # Define particle&#39;s and fluid&#39;s parameters
        rho_p = [5.0, 1.0, 0.01]        # Particle&#39;s density
        rho_f = 1.0                                     # Fluid&#39;s density 
        rad_p = np.sqrt(3)                      # Particle&#39;s radius
        nu_f = 1.0                                      # Kinematic viscocity
        t_scale = 100.0                         # Time scale of the flow

        # Import chosen velocity field
        vel = QuiescentFlow() # quiescent velocity field

        # Define number of nodes per time step
        nodes_dt = 20 # Nodes in each time step

        # Definition of the pseudo-spatial grid for Fokas
        N_fokas = 101 # Nodes in the frequency domain

        # Decide whether to apply parallel computing
        parallel_flag = True
        number_cores  = int(mp.cpu_count())

        # Define particle&#39;s initial conditions
        x0, y0    = 0.0, 0.0
        u0, v0    = 1.0, 0.0

        # Create particles and calculate their velocities
        particle1 = MaxeyRileyFokas(1, np.array([x0, y0]), np.array([u0, v0]),
                                                                vel, N_fokas, tini, dt, nodes_dt,
                                                                particle_density=rho_p[0],
                                                                fluid_density=rho_f,
                                                                particle_radius=rad_p,
                                                                kinematic_viscosity=nu_f,
                                                                time_scale=t_scale)
        q0_1_vec = np.array([u0, v0])
        for tt in progressbar(range(1, len(taxis))):
                particle1.update()
                q0_1_vec = np.vstack((q0_1_vec, particle1.q_vec[tt * (nodes_dt-1)]))

        particle2 = MaxeyRileyFokas(2, np.array([x0, y0]), np.array([u0, v0]),
                                                                vel, N_fokas, tini, dt, nodes_dt,
                                                                particle_density=rho_p[1],
                                                                fluid_density=rho_f,
                                                                particle_radius=rad_p,
                                                                kinematic_viscosity=nu_f,
                                                                time_scale=t_scale)
        q0_2_vec = np.array([u0, v0])
        for tt in progressbar(range(1, len(taxis))):
                particle2.update()
                q0_2_vec = np.vstack((q0_2_vec, particle2.q_vec[tt * (nodes_dt-1)]))

        particle3 = MaxeyRileyFokas(3, np.array([x0, y0]), np.array([u0, v0]),
                                                                vel, N_fokas, tini, dt, nodes_dt,
                                                                particle_density=rho_p[2],
                                                                fluid_density=rho_f,
                                                                particle_radius=rad_p,
                                                                kinematic_viscosity=nu_f,
                                                                time_scale=t_scale)
        q0_3_vec = np.array([u0, v0])
        for tt in progressbar(range(1, len(taxis))):
                particle3.update()
                q0_3_vec = np.vstack((q0_3_vec, particle3.q_vec[tt * (nodes_dt-1)]))

        # Create particles and calculate their trajectories
        u0, v0 = 1.0, 1.0
        particle4 = MaxeyRileyFokas(4, np.array([x0, y0]), np.array([u0, v0]),
                                                                vel, N_fokas, tini, dt, nodes_dt,
                                                                particle_density=rho_p[0],
                                                                fluid_density=rho_f,
                                                                particle_radius=rad_p,
                                                                kinematic_viscosity=nu_f,
                                                                time_scale=t_scale)
        pos1_vec = np.array([x0, y0])
        for tt in progressbar(range(1, len(taxis))):
                particle4.update()
                pos1_vec = np.vstack((pos1_vec,
                                                          particle4.pos_vec[tt * (nodes_dt - 1)]))

        particle5 = MaxeyRileyFokas(5, np.array([x0, y0]), np.array([u0, v0]),
                                                                vel, N_fokas, tini, dt, nodes_dt,
                                                                particle_density=rho_p[1],
                                                                fluid_density=rho_f,
                                                                particle_radius=rad_p,
                                                                kinematic_viscosity=nu_f,
                                                                time_scale=t_scale)
        pos2_vec = np.array([x0, y0])
        for tt in progressbar(range(1, len(taxis))):
                particle5.update()
                pos2_vec = np.vstack((pos2_vec,
                                                          particle5.pos_vec[tt * (nodes_dt - 1)]))

        particle6 = MaxeyRileyFokas(6, np.array([x0, y0]), np.array([u0, v0]),
                                                                vel, N_fokas, tini, dt, nodes_dt,
                                                                particle_density=rho_p[2],
                                                                fluid_density=rho_f,
                                                                particle_radius=rad_p,
                                                                kinematic_viscosity=nu_f,
                                                                time_scale=t_scale)
        pos3_vec = np.array([x0, y0])
        for tt in progressbar(range(1, len(taxis))):
                particle6.update()
                pos3_vec = np.vstack((pos3_vec,
                                                          particle6.pos_vec[tt * (nodes_dt - 1)]))

        # Store results and write to a csv file
        numerics = pd.DataFrame({&#39;t_numerical&#39;: taxis,
                                                         &#39;q01&#39;: 1 + q0_1_vec[:, 1],
                                                         &#39;q02&#39;: 1 + q0_2_vec[:, 1],
                                                         &#39;q03&#39;: 1 + q0_3_vec[:, 1],
                                                         &#39;x1&#39;: pos1_vec[:, 0],
                                                         &#39;z1&#39;: pos1_vec[:, 1],
                                                         &#39;x2&#39;: pos2_vec[:, 0],
                                                         &#39;z2&#39;: pos2_vec[:, 1],
                                                         &#39;x3&#39;: pos3_vec[:, 0],
                                                         &#39;z3&#39;: pos3_vec[:, 1]})
        if __name__ == &#39;__main__&#39;:
                numerics.to_csv(&#39;../data/numerical_results.csv&#39;, index=False)
main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a02_NUMERICS.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Produces numerical solutions for a particle's motion in a fluid flow.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>Based on work by author cfg4065.</li>
<li>The nonlinear solving process may not converge if two consecutive time
nodes are too close to each other (for example if a large amount of nodes
is provided). This could be addressed by either (1) changing the
nonlinear solver, (2) increasing the number of maximum iterations or (3)
decreasing the tolerance. These parameters can be changed in the
<code>a09_PRTCLE_FOKAS script</code>, under the <code>update</code> method.</li>
<li>The velocity field is defined in the <code>a03_FIELD0_QUIESCENT</code> file, whose
class is imported.</li>
<li>Changing the parameters related to the time grid, i.e. <code>tini</code>, <code>tend</code>,
<code>nt</code>, may require a recalculation of the matrix values to ensure
convergence of the nonlinear solver (automatically done by the ToolBox by
deleting the <code>a00_MATRX_VALUES.txt</code> file).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
        &#34;&#34;&#34;
        Produces numerical solutions for a particle&#39;s motion in a fluid flow.

        Notes
        -----
        - Based on work by author cfg4065.
        - The nonlinear solving process may not converge if two consecutive time
          nodes are too close to each other (for example if a large amount of nodes 
          is provided). This could be addressed by either (1) changing the 
          nonlinear solver, (2) increasing the number of maximum iterations or (3) 
          decreasing the tolerance. These parameters can be changed in the 
          `a09_PRTCLE_FOKAS script`, under the `update` method.
        - The velocity field is defined in the `a03_FIELD0_QUIESCENT` file, whose
          class is imported.
        - Changing the parameters related to the time grid, i.e. `tini`, `tend`,
          `nt`, may require a recalculation of the matrix values to ensure
          convergence of the nonlinear solver (automatically done by the ToolBox by 
          deleting the `a00_MATRX_VALUES.txt` file).
        &#34;&#34;&#34;
        # Define time grid
        tini = 0.0      # Initial time
        tend = 10.0     # Final time
        nt = 6
        #nt = 351       # Time nodes, delta t approx 0.03
        #nt = 2327      # Time nodes, delta t approx 0.0043

        # Create time axis, where S = 0.01
        taxis  = np.linspace(tini, tend, nt)
        dt = taxis[1] - taxis[0]

        # Define particle&#39;s and fluid&#39;s parameters
        rho_p = [5.0, 1.0, 0.01]        # Particle&#39;s density
        rho_f = 1.0                                     # Fluid&#39;s density 
        rad_p = np.sqrt(3)                      # Particle&#39;s radius
        nu_f = 1.0                                      # Kinematic viscocity
        t_scale = 100.0                         # Time scale of the flow

        # Import chosen velocity field
        vel = QuiescentFlow() # quiescent velocity field

        # Define number of nodes per time step
        nodes_dt = 20 # Nodes in each time step

        # Definition of the pseudo-spatial grid for Fokas
        N_fokas = 101 # Nodes in the frequency domain

        # Decide whether to apply parallel computing
        parallel_flag = True
        number_cores  = int(mp.cpu_count())

        # Define particle&#39;s initial conditions
        x0, y0    = 0.0, 0.0
        u0, v0    = 1.0, 0.0

        # Create particles and calculate their velocities
        particle1 = MaxeyRileyFokas(1, np.array([x0, y0]), np.array([u0, v0]),
                                                                vel, N_fokas, tini, dt, nodes_dt,
                                                                particle_density=rho_p[0],
                                                                fluid_density=rho_f,
                                                                particle_radius=rad_p,
                                                                kinematic_viscosity=nu_f,
                                                                time_scale=t_scale)
        q0_1_vec = np.array([u0, v0])
        for tt in progressbar(range(1, len(taxis))):
                particle1.update()
                q0_1_vec = np.vstack((q0_1_vec, particle1.q_vec[tt * (nodes_dt-1)]))

        particle2 = MaxeyRileyFokas(2, np.array([x0, y0]), np.array([u0, v0]),
                                                                vel, N_fokas, tini, dt, nodes_dt,
                                                                particle_density=rho_p[1],
                                                                fluid_density=rho_f,
                                                                particle_radius=rad_p,
                                                                kinematic_viscosity=nu_f,
                                                                time_scale=t_scale)
        q0_2_vec = np.array([u0, v0])
        for tt in progressbar(range(1, len(taxis))):
                particle2.update()
                q0_2_vec = np.vstack((q0_2_vec, particle2.q_vec[tt * (nodes_dt-1)]))

        particle3 = MaxeyRileyFokas(3, np.array([x0, y0]), np.array([u0, v0]),
                                                                vel, N_fokas, tini, dt, nodes_dt,
                                                                particle_density=rho_p[2],
                                                                fluid_density=rho_f,
                                                                particle_radius=rad_p,
                                                                kinematic_viscosity=nu_f,
                                                                time_scale=t_scale)
        q0_3_vec = np.array([u0, v0])
        for tt in progressbar(range(1, len(taxis))):
                particle3.update()
                q0_3_vec = np.vstack((q0_3_vec, particle3.q_vec[tt * (nodes_dt-1)]))

        # Create particles and calculate their trajectories
        u0, v0 = 1.0, 1.0
        particle4 = MaxeyRileyFokas(4, np.array([x0, y0]), np.array([u0, v0]),
                                                                vel, N_fokas, tini, dt, nodes_dt,
                                                                particle_density=rho_p[0],
                                                                fluid_density=rho_f,
                                                                particle_radius=rad_p,
                                                                kinematic_viscosity=nu_f,
                                                                time_scale=t_scale)
        pos1_vec = np.array([x0, y0])
        for tt in progressbar(range(1, len(taxis))):
                particle4.update()
                pos1_vec = np.vstack((pos1_vec,
                                                          particle4.pos_vec[tt * (nodes_dt - 1)]))

        particle5 = MaxeyRileyFokas(5, np.array([x0, y0]), np.array([u0, v0]),
                                                                vel, N_fokas, tini, dt, nodes_dt,
                                                                particle_density=rho_p[1],
                                                                fluid_density=rho_f,
                                                                particle_radius=rad_p,
                                                                kinematic_viscosity=nu_f,
                                                                time_scale=t_scale)
        pos2_vec = np.array([x0, y0])
        for tt in progressbar(range(1, len(taxis))):
                particle5.update()
                pos2_vec = np.vstack((pos2_vec,
                                                          particle5.pos_vec[tt * (nodes_dt - 1)]))

        particle6 = MaxeyRileyFokas(6, np.array([x0, y0]), np.array([u0, v0]),
                                                                vel, N_fokas, tini, dt, nodes_dt,
                                                                particle_density=rho_p[2],
                                                                fluid_density=rho_f,
                                                                particle_radius=rad_p,
                                                                kinematic_viscosity=nu_f,
                                                                time_scale=t_scale)
        pos3_vec = np.array([x0, y0])
        for tt in progressbar(range(1, len(taxis))):
                particle6.update()
                pos3_vec = np.vstack((pos3_vec,
                                                          particle6.pos_vec[tt * (nodes_dt - 1)]))

        # Store results and write to a csv file
        numerics = pd.DataFrame({&#39;t_numerical&#39;: taxis,
                                                         &#39;q01&#39;: 1 + q0_1_vec[:, 1],
                                                         &#39;q02&#39;: 1 + q0_2_vec[:, 1],
                                                         &#39;q03&#39;: 1 + q0_3_vec[:, 1],
                                                         &#39;x1&#39;: pos1_vec[:, 0],
                                                         &#39;z1&#39;: pos1_vec[:, 1],
                                                         &#39;x2&#39;: pos2_vec[:, 0],
                                                         &#39;z2&#39;: pos2_vec[:, 1],
                                                         &#39;x3&#39;: pos3_vec[:, 0],
                                                         &#39;z3&#39;: pos3_vec[:, 1]})
        if __name__ == &#39;__main__&#39;:
                numerics.to_csv(&#39;../data/numerical_results.csv&#39;, index=False)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle" href="index.html">modelling-microplastics-transport.examples.sedimenting_particle</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a02_NUMERICS.main" href="#modelling-microplastics-transport.examples.sedimenting_particle.a02_NUMERICS.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>