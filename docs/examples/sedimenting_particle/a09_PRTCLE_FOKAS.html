<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys 
sys.path.append(&#39;/home/s2182576/Documents/academia/thesis/&#39;
                                + &#39;modelling-microplastics-transport/examples/&#39;
                                + &#39;sedimenting_particle&#39;)
import numpy as np
import numpy.polynomial.chebyshev as cheb
import time
from scipy.integrate import quad
from scipy.optimize import newton, newton_krylov, fsolve, broyden1
from scipy.sparse.linalg import spsolve
from os.path import exists
from progressbar import progressbar
from a00_PMTERS_CONST import MaxeyRileyParameter

class MaxeyRileyFokas(object):
        &#34;&#34;&#34;
        Calculates the trajectory and velocity of a particle whose dynamics are
        governed by the Maxey-Riley equation, using the Fokas method described in
        Prasath et al. (2019).
        &#34;&#34;&#34;

        def __init__(self, tag, x, v, velocity_field, Nz, t0, dt, time_nodes,
                                 particle_density=1, fluid_density=1, particle_radius=1,
                                 kinematic_viscosity=1, time_scale=1):
                &#34;&#34;&#34;
                Attributes
                ----------
                tag     : str or int
                        Particle name or tag.
                x : array
                        The initial position of the particle.
                v : array
                        The initial velocity of the particle.
                velocity_field : VelocityField (obj)
                        The velocity field through which the particle is travelling.
                Nz : int
                        The number of nodes in the frequency domain.
                t0 : float
                        The initial time.
                dt : float
                        The time step delta t.
                time_nodes : int
                        The number of nodes in each time step.
                particle_density : float, default=1
                        The density of the particle, rho_p.
                fluid_density : float, default=1
                        The density of the fluid, rho_f.
                particle_radius : float, default=1
                        The radius of the particle *a*.
                kinematic_viscosity : float, default=1
                        The kinematic viscosity *nu*.
                time_scale : float, default=1
                        The time scale of the flow.
                &#34;&#34;&#34;
                self.tag = tag
                self.t0 = t0
                self.time = t0
                self.dt = dt
                self.x = x[0]
                self.y = x[1]
                self.vel = velocity_field
                u0, v0 = velocity_field.get_velocity(x[0], x[1], t0)
          
                self.qx_tj = np.zeros([1, Nz])[0]
                self.qx_tj[0] = v[0] - u0       # Initial condition at subdomain
                self.qy_tj = np.zeros([1, Nz])[0]
                self.qy_tj[0] = v[1] - v0       # Initial condition at subdomain
          
                self.q0 = np.array([self.qx_tj[0], self.qy_tj[0]])
                self.p = MaxeyRileyParameter(particle_density, fluid_density,
                                                                         particle_radius, kinematic_viscosity,
                                                                         time_scale)
                self.time_nodes = time_nodes
          
                index_v = np.arange(0, Nz)
                self.z_hat_v = (1 - np.cos(index_v * np.pi / Nz)) - 1
                self.z_v = (1 + self.z_hat_v) / (1 - self.z_hat_v)
          
                #self.k_v = np.arange(0.0, 200.0, 1e-2) 
                self.k_hat_v = (1 - np.cos(index_v * np.pi / Nz)) - 1
                self.k_v = (1 + self.k_hat_v) / (1 - self.k_hat_v)
          
                self.pos_vec = np.copy(x)
                self.q_vec = np.copy(self.q0)
          
                if self.vel.limits == True:
                        if (self.x[0] &gt; self.vel.x_right or self.x[0] &lt; self.vel.x_left \
                                or self.x[1] &gt; self.vel.y_up or self.x[1] &lt; self.vel.y_down):
                                raise Exception(&#39;Particle\&#39;s initial position is outside the &#39;
                                                                + &#39;spatial domain.&#39;) 
          
                self.qx_x0 = np.zeros([1, time_nodes])[0]
                self.qx_x0[0] = self.q0[0] #v[0] - u0
                self.qy_x0 = np.zeros([1, time_nodes])[0]
                self.qy_x0[0] = self.q0[1] #v[1] - v0
          
                self.interval_def()
                self.M_nn()
          
        def interval_def(self):
                &#34;&#34;&#34;
                Defines chebyshev nodes in time subdomain [t_i, ti + dt], 
                i.e. s_1, s_2, ...
                &#34;&#34;&#34;
                self.time_vec = np.array([])
                x = np.array([])
                y = np.array([])
                for jj in range(0, self.time_nodes):
                        self.time_vec  = np.append(self.time_vec, self.time + 0.5 \
                                                                           * self.dt * (1 - np.cos(jj * np.pi 
                                                                           / (self.time_nodes - 1))))
                        if self.time - self.t0 == 0:
                                x = np.append(x, self.x)
                                y = np.append(y, self.y)
                        else:
                                x = np.append(x, self.x[-1])
                                y = np.append(y, self.y[-1])
                self.x0_v = np.append(x, y)
        
        def Lm(self, m):
                r&#34;&#34;&#34;
                Calculates L(m) function,
                $$\mathcal{L}(m) = \int_0^{\infty}
                \frac{k^2 \gamma e^{-k^2 m}}{k^2 \gamma^2 + (k^2 - \alpha)^2} dk,$$
                used to obtain matrix M and then F.
                &#34;&#34;&#34;     
                fun_exp = lambda k: np.exp(-m * k ** 2)
                fun_frac = lambda k: self.p.gamma * k ** 2 / \
                                   ((k * self.p.gamma) ** 2 + (k ** 2 - self.p.alpha) ** 2)     
                fun = lambda k: fun_exp(k) * fun_frac(k)
                fun_v = np.array([])

                for kk in range(0, len(self.k_v)):
                        fun_v = np.append(fun_v, fun(self.k_v[kk]))
                
                coeff = cheb.chebfit(self.k_hat_v, fun_v, len(self.k_v) - 1)
                coeff_int = cheb.chebint(coeff)
                result = cheb.chebval(1, coeff_int) - cheb.chebval(-1, coeff_int)
                return result
        
        def M_nn(self):
                &#34;&#34;&#34;Calculates matrix M.&#34;&#34;&#34;
                name_file = &#39;a00_MATRX_VALUES.txt&#39;
                
                if exists(name_file) == True:
                        with open(name_file, &#39;rb&#39;) as file:
                                mat = np.load(file)
                
                if exists(name_file) == False or mat.shape[0] != len(self.time_vec):
                        #print(&#39;Creating Matrix.&#39;)
                        time.sleep(0.3)
                        #time1   = time.time()
                        mat      = np.zeros([len(self.time_vec),len(self.time_vec)])
                
                        for ii in progressbar(range(1,len(self.time_vec))):
                                for nn in range(0,len(self.time_vec)):
                                        # Create vector of coeffs to define Chebyshev polynomial
                                        coeff     = np.zeros([1,len(self.time_vec)])[0]

                                        # Fill in the element of the vector corresponding to the
                                        # matrix entry
                                        coeff[nn]  = 1
                                        poly = cheb.Chebyshev(coeff) # change into Cheb polynomial

                                        # Create function of full integrand of the matrix element
                                        fun     = lambda s: poly(s) * self.Lm(self.time_vec[ii]-s)
                                        aux = quad(fun, self.time_vec[0], self.time_vec[ii],
                                                           epsrel=1e-9, epsabs=1e-9, limit=1000,
                                                           points=[self.time_vec[ii]]) # integrate
                                        mat[ii][nn] = aux[0] # fill in matrix

                                        # Display values
                                        #print(&#39;position [t_&#39;,ii,&#39;, T_&#39;,nn,&#39;]:&#39;,mat[ii][nn])
                                        #print(&#39;error:&#39;,aux[1])
                
                        with open(name_file, &#39;wb&#39;) as file:
                                np.save(file, mat)
                        
                self.M = mat
                #time2 = time.time()
                #print(&#34;Time to calculate Matrix: &#34; + str(time2-time1))

        def calculate_f(self):
                &#34;&#34;&#34;
                Define forcing function f(q(0, t)). This will differ for different 
                boundary problems.
                &#34;&#34;&#34;
                return 0, self.p.sigma
  
        def F(self, q_guess, x_guess):
                &#34;&#34;&#34;Calculates F(t_j).&#34;&#34;&#34;        
                # Change solution guess according to function f
                f_vec     = np.array([])
                g_vec     = np.array([])
                
                for tt in range(0,len(self.time_vec)):
                        q_vec  = np.array([q_guess[tt],
                                                           q_guess[tt + int(len(q_guess) / 2)]])
                        x_vec  = np.array([x_guess[tt],
                                                           x_guess[tt + int(len(x_guess) / 2)]])
                        f, g   = self.calculate_f()
                        f_vec  = np.append(f_vec, f)
                        g_vec  = np.append(g_vec, g)
                
                self.f_vec = f_vec
                self.g_vec = g_vec
                
                # Approximate by Chebyshev coeff
                coeff_x = cheb.chebfit(self.time_vec-self.time_vec[0],
                                                           f_vec, len(self.time_vec)-1)
                coeff_y = cheb.chebfit(self.time_vec-self.time_vec[0],
                                                           g_vec, len(self.time_vec)-1)
                
                # Obtain F as the dot product of the coeff times the matrix entries
                result_x   = np.array([])
                result_y   = np.array([])
                for jj in range(0,len(self.time_vec)):
                        result_x  = np.append(result_x, (2.0/np.pi) \
                                                                  * np.dot(coeff_x, self.M[jj]))
                        result_y  = np.append(result_y, (2.0/np.pi) \
                                                                  * np.dot(coeff_y, self.M[jj]))
                
                result_v = np.append(result_x, result_y)
                return result_v

        def q_hat(self, k):
                &#34;&#34;&#34;Calculates q hat&#34;&#34;&#34;     
                intgnd_x = np.exp(1j * k * self.z_v) * self.qx_tj * 2 \
                                                         / (1 - self.z_hat_v) ** 2
                intgnd_y = np.exp(1j * k * self.z_v) * self.qy_tj * 2 \
                                                         / (1 - self.z_hat_v) ** 2
                
                coeff_x = cheb.chebfit(self.z_hat_v, intgnd_x, len(self.z_hat_v) - 1)
                coeff_y = cheb.chebfit(self.z_hat_v, intgnd_y, len(self.z_hat_v) - 1)
                coeffx_int = cheb.chebint(coeff_x)
                coeffy_int = cheb.chebint(coeff_y)      
                result_x = cheb.chebval(1, coeffx_int) - cheb.chebval(-1, coeffx_int)
                result_y = cheb.chebval(1, coeffy_int) - cheb.chebval(-1, coeffy_int)
                result   = np.array([[result_x], [result_y]])
                return result

        def G_fun(self):
                &#34;&#34;&#34;Calculates G.&#34;&#34;&#34;     
                resultx_v = np.array([])
                resulty_v = np.array([])

                for k in self.k_v:
                        q_hat = self.q_hat(k)
                        fun_num_x  = (1j * k * self.p.gamma - (k ** 2 - self.p.alpha)) \
                                                         * (self.p.gamma * q_hat[0] + self.qx_x0[0])
                        fun_num_y  = (1j * k * self.p.gamma - (k ** 2 - self.p.alpha)) \
                                                         * (self.p.gamma * q_hat[1] + self.qy_x0[0])
                        fun_den = - (k * self.p.gamma) ** 2 - (k ** 2 - self.p.alpha) ** 2
                        resultx_v  = np.append(resultx_v, fun_num_x / fun_den)
                        resulty_v  = np.append(resulty_v, fun_num_y / fun_den)
                
                result_v = np.array([resultx_v, resulty_v])             
                self.G_v_imag = result_v.imag
                return result_v.imag
        
        def G_update(self):
                &#34;&#34;&#34;Updates the term G.&#34;&#34;&#34;
                #f_vec = np.array([[],[]])
                f_tld_x_v = np.array([])
                f_tld_y_v = np.array([])
                self.fx_vector = np.array([])
                self.fy_vector = np.array([])
                
                for k in self.k_v:
                        # Approximate by Chebyshev coeff
                        exponent = -(self.time_old_v[-1] - self.time_old_v) * k ** 2
                        exponent[exponent &lt; -1e2] = -100.0
                        
                        coeff_x = cheb.chebfit(self.time_old_v,
                                                                   np.exp(exponent) * self.f_vec,
                                                                   len(self.time_old_v) - 1)
                        coeff_y = cheb.chebfit(self.time_old_v,
                                                                   np.exp(exponent) * self.g_vec,
                                                                   len(self.time_old_v) - 1)

                        coeffx_int = cheb.chebint(coeff_x)
                        coeffy_int = cheb.chebint(coeff_y)

                        f_tld_x = cheb.chebval(self.time_old_v[-1], coeffx_int) \
                                          - cheb.chebval(self.time_old_v[0], coeffx_int)
                        f_tld_y = cheb.chebval(self.time_old_v[-1], coeffy_int) \
                                          - cheb.chebval(self.time_old_v[0], coeffy_int)
                        
                        self.fx_vector = np.append(self.fx_vector, f_tld_x)
                        self.fy_vector = np.append(self.fy_vector, f_tld_y)
                        
                        f_tld_x_frac = k * self.p.gamma * f_tld_x \
                                                         / ((k * self.p.gamma) ** 2
                                                          + (k ** 2 - self.p.alpha) ** 2)
                        f_tld_y_frac = k * self.p.gamma * f_tld_y \
                                                         / ((k * self.p.gamma) ** 2 
                                                         + (k ** 2 - self.p.alpha) ** 2)
                        
                        f_tld_x_v = np.append(f_tld_x_v, f_tld_x_frac)
                        f_tld_y_v = np.append(f_tld_y_v, f_tld_y_frac)
                        
                self.f_tld_x = f_tld_x_v
                self.f_tld_y = f_tld_y_v

                exponentx = -self.k_v ** 2 * self.dt
                exponentx[exponentx &lt;-1e2] = -100
                resultx_v = np.exp(exponentx) * self.G_v_imag[0] - f_tld_x_v            

                exponenty = -self.k_v ** 2 * self.dt
                exponenty[exponenty &lt;-1e2] = -100
                resulty_v = np.exp(exponenty) * self.G_v_imag[1] - f_tld_y_v
                
                resultx_v[abs(resultx_v) &lt; 1e-15] = 0
                resulty_v[abs(resulty_v) &lt; 1e-15] = 0
                result_v = np.array([resultx_v, resulty_v])             
                self.G_v_imag = result_v
                return result_v
        
        def H(self):
                &#34;&#34;&#34;Calculates H.&#34;&#34;&#34;
                if self.time_vec[0] - self.t0 == 0:
                        self.G_fun()
                else:
                        self.G_update()
                resultx_v = np.array([])
                resulty_v = np.array([])
                
                for jj in range(1, len(self.time_vec)):         
                        exponent = np.log((2 / np.pi) * 2 / (1 - self.k_hat_v) ** 2) \
                                           - (self.time_vec[jj] - self.time_vec[0]) * self.k_v ** 2
                        exponent[exponent &lt; -1e2] = -100

                        Hx_intgrnd = -np.exp(exponent) * self.G_v_imag[0] * self.k_v
                        Hy_intgrnd = -np.exp(exponent) * self.G_v_imag[1] * self.k_v
                        Hx_intgrnd[abs(Hx_intgrnd) &lt; 1e-40] = 0
                        Hy_intgrnd[abs(Hy_intgrnd) &lt; 1e-40] = 0

                        coeff_x = cheb.chebfit(self.k_hat_v, Hx_intgrnd,
                                                                   len(self.k_hat_v) - 1)
                        coeff_y = cheb.chebfit(self.k_hat_v, Hy_intgrnd,
                                                                   len(self.k_hat_v) - 1)
                        coeffx_int = cheb.chebint(coeff_x)
                        coeffy_int = cheb.chebint(coeff_y)

                        resultx_v = np.append(resultx_v, cheb.chebval(1, coeffx_int) \
                                                 - cheb.chebval(-1, coeffx_int))
                        resulty_v = np.append(resulty_v, cheb.chebval(1, coeffy_int) \
                                                 - cheb.chebval(-1, coeffy_int))
                        
                if self.time_vec[0] - self.t0 == 0:
                        resultx_v = np.append(self.qx_x0[0], resultx_v)
                        resulty_v = np.append(self.qy_x0[0], resulty_v)
                else:
                        resultx_v = np.append(self.qx_x0[-1], resultx_v)
                        resulty_v = np.append(self.qy_x0[-1], resulty_v)
                
                result_v   = np.append(resultx_v, resulty_v)
                self.H_v   = result_v
                return resultx_v, resulty_v
        
        def eta(self, q_guess):
                &#34;&#34;&#34;Calculates eta.&#34;&#34;&#34;
                q_v     = np.array([])
                p_v     = np.array([])
                for tt in range(0, len(self.time_vec)):
                        q_v = np.append(q_v, q_guess[tt])
                        p_v = np.append(p_v, q_guess[tt+int(len(q_guess)/2)])
                
                coeff_x = cheb.chebfit(self.time_vec, q_v, len(self.time_vec)-1)
                coeff_y = cheb.chebfit(self.time_vec, p_v, len(self.time_vec)-1)
                intcoeff_x = cheb.chebint(coeff_x)
                intcoeff_y = cheb.chebint(coeff_y)
                value_x_0 = cheb.chebval(self.time_vec[0], intcoeff_x)
                value_y_0 = cheb.chebval(self.time_vec[0], intcoeff_y)
                
                resultx_v = np.array([0])
                resulty_v = np.array([0])
                for tt in range(1, len(self.time_vec)):
                        resultx_v = np.append(resultx_v, cheb.chebval(self.time_vec[tt],
                                                                  intcoeff_x) - value_x_0)
                        resulty_v = np.append(resulty_v, cheb.chebval(self.time_vec[tt],
                                                                  intcoeff_y) - value_y_0)
                
                result_v   = np.append(resultx_v, resulty_v)
                return result_v
        
        def Psi(self, x_guess):
                &#34;&#34;&#34;Calculates psi.&#34;&#34;&#34;
                U_v = np.array([])
                V_v     = np.array([])
                for tt in range(0, len(self.time_vec)):
                        x = x_guess[tt]
                        y = x_guess[tt + int(len(x_guess)/2)]
                        u, v = self.vel.get_velocity(x, y, self.time_vec[tt])
                        U_v = np.append(U_v, u)
                        V_v = np.append(V_v, v)
                
                coeff_x = cheb.chebfit(self.time_vec, U_v, len(self.time_vec)-1)
                coeff_y = cheb.chebfit(self.time_vec, V_v, len(self.time_vec)-1)
                intcoeff_x = cheb.chebint(coeff_x)
                intcoeff_y = cheb.chebint(coeff_y)
                value_x_0 = cheb.chebval(self.time_vec[0], intcoeff_x)
                value_y_0 = cheb.chebval(self.time_vec[0], intcoeff_y)
                
                resultx_v = np.array([0])
                resulty_v = np.array([0])
                for tt in range(1, len(self.time_vec)):
                        resultx_v = np.append(resultx_v, cheb.chebval(self.time_vec[tt],
                                                                  intcoeff_x) - value_x_0)
                        resulty_v = np.append(resulty_v, cheb.chebval(self.time_vec[tt],
                                                                  intcoeff_y) - value_y_0)
                
                result_v = np.append(resultx_v, resulty_v)
                return result_v
        
        def J(self,guess):
                &#34;&#34;&#34;Defines the function J to obtain rules on.&#34;&#34;&#34;
                q_guess = guess[:len(self.time_vec)*2]
                x_guess = guess[len(self.time_vec)*2:]
                
                # Define function J, on which Newton method is used.
                J_v     = q_guess - self.F(q_guess, x_guess) - self.H_v
                Psi_v = self.x0_v - x_guess + self.eta(q_guess) + self.Psi(x_guess)     
                result_v = np.append(J_v, Psi_v)
                return result_v
        
        # Function that runs nonlinear solver and calculates solution at boundary.
        def update(self):
                &#34;&#34;&#34;Updates the velocity and trajectory of the particle.&#34;&#34;&#34;      
                q_guess, p_guess = self.H()     # guess for the relative velocity
                
                if self.time - self.t0 == 0:
                        x_guess = np.array([self.x])
                        y_guess = np.array([self.y])
                else:
                        x_guess = np.array([self.x[-1]])
                        y_guess = np.array([self.y[-1]])
                
                # guess for the position
                for tt in range(0, len(self.time_vec)-1):
                        dt = self.time_vec[tt+1] - self.time_vec[tt]
                        q, p = q_guess[tt], p_guess[tt]
                        u, v = self.vel.get_velocity(x_guess[-1], y_guess[-1],
                                                                                 self.time_vec[tt])
                        x_guess = np.append(x_guess, x_guess[-1] + dt * (q + u))
                        y_guess = np.append(y_guess, y_guess[-1] + dt * (p + v))
                
                vel_guess = np.append(q_guess, p_guess)
                pos_guess = np.append(x_guess, y_guess)
                guess = np.append(vel_guess, pos_guess)
                
                # Newton-Raphson method
                #print(&#34;Initial guess: \n&#34; + str(guess))
                iter_limit = 1000
                tolerance  = 1e-13
                
                try:
                        result = newton(self.J, guess, maxiter=iter_limit, tol=tolerance,
                                                        full_output=True)

                        # Check method converged before reaching maxiter.
                        if any(np.invert(result[1])) == False: # Method converged!
                                solution = result[0]
                        else:
                                raise
                except:
                        try: # Try Newton method with Krylov inverse Jacobian approximation.
                                solution = newton_krylov(self.J, guess, maxiter=iter_limit,
                                                                                 f_tol=tolerance)
                        # If everything failed, use fsolve, which is slower but more stable.
                        except:
                                solution = fsolve(self.J, guess, maxfev=iter_limit,
                                                                  xtol=tolerance)
                
                #print(&#34;G: &#34; + str(self.G_v_imag))
                self.q_x0 = np.copy(solution)
                self.qx_x0 = np.copy(solution[:len(self.time_vec)])
                self.qy_x0 = np.copy(solution[len(self.time_vec): 2*len(self.time_vec)])
                self.x = np.copy(solution[2 * len(self.time_vec): 3*len(self.time_vec)])
                self.y = np.copy(solution[3 * len(self.time_vec):])
                
                #print(&#34;2 norm: \n&#34; + str(np.linalg.norm(self.J(self.q_x0))))
                #print(&#34;Inf norm: \n&#34; + str(np.linalg.norm(self.J(self.q_x0),np.inf)))
                #print(&#34;Method&#39;s convergence: \n&#34; + str(result[1]))
                #print(&#34;Solution: \nq_1: &#34;+str(self.qx_x0)+&#34;\nq_2: &#34;+str(self.qy_x0))
                #assert (not any(np.invert(result[1]))), &#39;Method does not converge!&#39;
                
                pos_vec = np.array([self.x[1:], self.y[1:]])
                q_vec = np.array([self.qx_x0[1:], self.qy_x0[1:]])
                self.pos_vec = np.vstack([self.pos_vec, np.transpose(pos_vec)])
                self.q_vec = np.vstack([self.q_vec, np.transpose(q_vec)])
                
                self.time_old_v = self.time_vec
                self.time += self.dt
                self.interval_def()
                
                return solution</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas"><code class="flex name class">
<span>class <span class="ident">MaxeyRileyFokas</span></span>
<span>(</span><span>tag, x, v, velocity_field, Nz, t0, dt, time_nodes, particle_density=1, fluid_density=1, particle_radius=1, kinematic_viscosity=1, time_scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the trajectory and velocity of a particle whose dynamics are
governed by the Maxey-Riley equation, using the Fokas method described in
Prasath et al. (2019).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt>tag
: str or int</dt>
<dt>Particle name or tag.</dt>
<dt><strong><code>x</code></strong> :&ensp;<code>array</code></dt>
<dd>The initial position of the particle.</dd>
<dt><strong><code>v</code></strong> :&ensp;<code>array</code></dt>
<dd>The initial velocity of the particle.</dd>
<dt><strong><code>velocity_field</code></strong> :&ensp;<code>VelocityField (obj)</code></dt>
<dd>The velocity field through which the particle is travelling.</dd>
<dt><strong><code>Nz</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of nodes in the frequency domain.</dd>
<dt><strong><code>t0</code></strong> :&ensp;<code>float</code></dt>
<dd>The initial time.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>The time step delta t.</dd>
<dt><strong><code>time_nodes</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of nodes in each time step.</dd>
<dt><strong><code>particle_density</code></strong> :&ensp;<code>float</code>, default=<code>1</code></dt>
<dd>The density of the particle, rho_p.</dd>
<dt><strong><code>fluid_density</code></strong> :&ensp;<code>float</code>, default=<code>1</code></dt>
<dd>The density of the fluid, rho_f.</dd>
<dt><strong><code>particle_radius</code></strong> :&ensp;<code>float</code>, default=<code>1</code></dt>
<dd>The radius of the particle <em>a</em>.</dd>
<dt><strong><code>kinematic_viscosity</code></strong> :&ensp;<code>float</code>, default=<code>1</code></dt>
<dd>The kinematic viscosity <em>nu</em>.</dd>
<dt><strong><code>time_scale</code></strong> :&ensp;<code>float</code>, default=<code>1</code></dt>
<dd>The time scale of the flow.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MaxeyRileyFokas(object):
        &#34;&#34;&#34;
        Calculates the trajectory and velocity of a particle whose dynamics are
        governed by the Maxey-Riley equation, using the Fokas method described in
        Prasath et al. (2019).
        &#34;&#34;&#34;

        def __init__(self, tag, x, v, velocity_field, Nz, t0, dt, time_nodes,
                                 particle_density=1, fluid_density=1, particle_radius=1,
                                 kinematic_viscosity=1, time_scale=1):
                &#34;&#34;&#34;
                Attributes
                ----------
                tag     : str or int
                        Particle name or tag.
                x : array
                        The initial position of the particle.
                v : array
                        The initial velocity of the particle.
                velocity_field : VelocityField (obj)
                        The velocity field through which the particle is travelling.
                Nz : int
                        The number of nodes in the frequency domain.
                t0 : float
                        The initial time.
                dt : float
                        The time step delta t.
                time_nodes : int
                        The number of nodes in each time step.
                particle_density : float, default=1
                        The density of the particle, rho_p.
                fluid_density : float, default=1
                        The density of the fluid, rho_f.
                particle_radius : float, default=1
                        The radius of the particle *a*.
                kinematic_viscosity : float, default=1
                        The kinematic viscosity *nu*.
                time_scale : float, default=1
                        The time scale of the flow.
                &#34;&#34;&#34;
                self.tag = tag
                self.t0 = t0
                self.time = t0
                self.dt = dt
                self.x = x[0]
                self.y = x[1]
                self.vel = velocity_field
                u0, v0 = velocity_field.get_velocity(x[0], x[1], t0)
          
                self.qx_tj = np.zeros([1, Nz])[0]
                self.qx_tj[0] = v[0] - u0       # Initial condition at subdomain
                self.qy_tj = np.zeros([1, Nz])[0]
                self.qy_tj[0] = v[1] - v0       # Initial condition at subdomain
          
                self.q0 = np.array([self.qx_tj[0], self.qy_tj[0]])
                self.p = MaxeyRileyParameter(particle_density, fluid_density,
                                                                         particle_radius, kinematic_viscosity,
                                                                         time_scale)
                self.time_nodes = time_nodes
          
                index_v = np.arange(0, Nz)
                self.z_hat_v = (1 - np.cos(index_v * np.pi / Nz)) - 1
                self.z_v = (1 + self.z_hat_v) / (1 - self.z_hat_v)
          
                #self.k_v = np.arange(0.0, 200.0, 1e-2) 
                self.k_hat_v = (1 - np.cos(index_v * np.pi / Nz)) - 1
                self.k_v = (1 + self.k_hat_v) / (1 - self.k_hat_v)
          
                self.pos_vec = np.copy(x)
                self.q_vec = np.copy(self.q0)
          
                if self.vel.limits == True:
                        if (self.x[0] &gt; self.vel.x_right or self.x[0] &lt; self.vel.x_left \
                                or self.x[1] &gt; self.vel.y_up or self.x[1] &lt; self.vel.y_down):
                                raise Exception(&#39;Particle\&#39;s initial position is outside the &#39;
                                                                + &#39;spatial domain.&#39;) 
          
                self.qx_x0 = np.zeros([1, time_nodes])[0]
                self.qx_x0[0] = self.q0[0] #v[0] - u0
                self.qy_x0 = np.zeros([1, time_nodes])[0]
                self.qy_x0[0] = self.q0[1] #v[1] - v0
          
                self.interval_def()
                self.M_nn()
          
        def interval_def(self):
                &#34;&#34;&#34;
                Defines chebyshev nodes in time subdomain [t_i, ti + dt], 
                i.e. s_1, s_2, ...
                &#34;&#34;&#34;
                self.time_vec = np.array([])
                x = np.array([])
                y = np.array([])
                for jj in range(0, self.time_nodes):
                        self.time_vec  = np.append(self.time_vec, self.time + 0.5 \
                                                                           * self.dt * (1 - np.cos(jj * np.pi 
                                                                           / (self.time_nodes - 1))))
                        if self.time - self.t0 == 0:
                                x = np.append(x, self.x)
                                y = np.append(y, self.y)
                        else:
                                x = np.append(x, self.x[-1])
                                y = np.append(y, self.y[-1])
                self.x0_v = np.append(x, y)
        
        def Lm(self, m):
                r&#34;&#34;&#34;
                Calculates L(m) function,
                $$\mathcal{L}(m) = \int_0^{\infty}
                \frac{k^2 \gamma e^{-k^2 m}}{k^2 \gamma^2 + (k^2 - \alpha)^2} dk,$$
                used to obtain matrix M and then F.
                &#34;&#34;&#34;     
                fun_exp = lambda k: np.exp(-m * k ** 2)
                fun_frac = lambda k: self.p.gamma * k ** 2 / \
                                   ((k * self.p.gamma) ** 2 + (k ** 2 - self.p.alpha) ** 2)     
                fun = lambda k: fun_exp(k) * fun_frac(k)
                fun_v = np.array([])

                for kk in range(0, len(self.k_v)):
                        fun_v = np.append(fun_v, fun(self.k_v[kk]))
                
                coeff = cheb.chebfit(self.k_hat_v, fun_v, len(self.k_v) - 1)
                coeff_int = cheb.chebint(coeff)
                result = cheb.chebval(1, coeff_int) - cheb.chebval(-1, coeff_int)
                return result
        
        def M_nn(self):
                &#34;&#34;&#34;Calculates matrix M.&#34;&#34;&#34;
                name_file = &#39;a00_MATRX_VALUES.txt&#39;
                
                if exists(name_file) == True:
                        with open(name_file, &#39;rb&#39;) as file:
                                mat = np.load(file)
                
                if exists(name_file) == False or mat.shape[0] != len(self.time_vec):
                        #print(&#39;Creating Matrix.&#39;)
                        time.sleep(0.3)
                        #time1   = time.time()
                        mat      = np.zeros([len(self.time_vec),len(self.time_vec)])
                
                        for ii in progressbar(range(1,len(self.time_vec))):
                                for nn in range(0,len(self.time_vec)):
                                        # Create vector of coeffs to define Chebyshev polynomial
                                        coeff     = np.zeros([1,len(self.time_vec)])[0]

                                        # Fill in the element of the vector corresponding to the
                                        # matrix entry
                                        coeff[nn]  = 1
                                        poly = cheb.Chebyshev(coeff) # change into Cheb polynomial

                                        # Create function of full integrand of the matrix element
                                        fun     = lambda s: poly(s) * self.Lm(self.time_vec[ii]-s)
                                        aux = quad(fun, self.time_vec[0], self.time_vec[ii],
                                                           epsrel=1e-9, epsabs=1e-9, limit=1000,
                                                           points=[self.time_vec[ii]]) # integrate
                                        mat[ii][nn] = aux[0] # fill in matrix

                                        # Display values
                                        #print(&#39;position [t_&#39;,ii,&#39;, T_&#39;,nn,&#39;]:&#39;,mat[ii][nn])
                                        #print(&#39;error:&#39;,aux[1])
                
                        with open(name_file, &#39;wb&#39;) as file:
                                np.save(file, mat)
                        
                self.M = mat
                #time2 = time.time()
                #print(&#34;Time to calculate Matrix: &#34; + str(time2-time1))

        def calculate_f(self):
                &#34;&#34;&#34;
                Define forcing function f(q(0, t)). This will differ for different 
                boundary problems.
                &#34;&#34;&#34;
                return 0, self.p.sigma
  
        def F(self, q_guess, x_guess):
                &#34;&#34;&#34;Calculates F(t_j).&#34;&#34;&#34;        
                # Change solution guess according to function f
                f_vec     = np.array([])
                g_vec     = np.array([])
                
                for tt in range(0,len(self.time_vec)):
                        q_vec  = np.array([q_guess[tt],
                                                           q_guess[tt + int(len(q_guess) / 2)]])
                        x_vec  = np.array([x_guess[tt],
                                                           x_guess[tt + int(len(x_guess) / 2)]])
                        f, g   = self.calculate_f()
                        f_vec  = np.append(f_vec, f)
                        g_vec  = np.append(g_vec, g)
                
                self.f_vec = f_vec
                self.g_vec = g_vec
                
                # Approximate by Chebyshev coeff
                coeff_x = cheb.chebfit(self.time_vec-self.time_vec[0],
                                                           f_vec, len(self.time_vec)-1)
                coeff_y = cheb.chebfit(self.time_vec-self.time_vec[0],
                                                           g_vec, len(self.time_vec)-1)
                
                # Obtain F as the dot product of the coeff times the matrix entries
                result_x   = np.array([])
                result_y   = np.array([])
                for jj in range(0,len(self.time_vec)):
                        result_x  = np.append(result_x, (2.0/np.pi) \
                                                                  * np.dot(coeff_x, self.M[jj]))
                        result_y  = np.append(result_y, (2.0/np.pi) \
                                                                  * np.dot(coeff_y, self.M[jj]))
                
                result_v = np.append(result_x, result_y)
                return result_v

        def q_hat(self, k):
                &#34;&#34;&#34;Calculates q hat&#34;&#34;&#34;     
                intgnd_x = np.exp(1j * k * self.z_v) * self.qx_tj * 2 \
                                                         / (1 - self.z_hat_v) ** 2
                intgnd_y = np.exp(1j * k * self.z_v) * self.qy_tj * 2 \
                                                         / (1 - self.z_hat_v) ** 2
                
                coeff_x = cheb.chebfit(self.z_hat_v, intgnd_x, len(self.z_hat_v) - 1)
                coeff_y = cheb.chebfit(self.z_hat_v, intgnd_y, len(self.z_hat_v) - 1)
                coeffx_int = cheb.chebint(coeff_x)
                coeffy_int = cheb.chebint(coeff_y)      
                result_x = cheb.chebval(1, coeffx_int) - cheb.chebval(-1, coeffx_int)
                result_y = cheb.chebval(1, coeffy_int) - cheb.chebval(-1, coeffy_int)
                result   = np.array([[result_x], [result_y]])
                return result

        def G_fun(self):
                &#34;&#34;&#34;Calculates G.&#34;&#34;&#34;     
                resultx_v = np.array([])
                resulty_v = np.array([])

                for k in self.k_v:
                        q_hat = self.q_hat(k)
                        fun_num_x  = (1j * k * self.p.gamma - (k ** 2 - self.p.alpha)) \
                                                         * (self.p.gamma * q_hat[0] + self.qx_x0[0])
                        fun_num_y  = (1j * k * self.p.gamma - (k ** 2 - self.p.alpha)) \
                                                         * (self.p.gamma * q_hat[1] + self.qy_x0[0])
                        fun_den = - (k * self.p.gamma) ** 2 - (k ** 2 - self.p.alpha) ** 2
                        resultx_v  = np.append(resultx_v, fun_num_x / fun_den)
                        resulty_v  = np.append(resulty_v, fun_num_y / fun_den)
                
                result_v = np.array([resultx_v, resulty_v])             
                self.G_v_imag = result_v.imag
                return result_v.imag
        
        def G_update(self):
                &#34;&#34;&#34;Updates the term G.&#34;&#34;&#34;
                #f_vec = np.array([[],[]])
                f_tld_x_v = np.array([])
                f_tld_y_v = np.array([])
                self.fx_vector = np.array([])
                self.fy_vector = np.array([])
                
                for k in self.k_v:
                        # Approximate by Chebyshev coeff
                        exponent = -(self.time_old_v[-1] - self.time_old_v) * k ** 2
                        exponent[exponent &lt; -1e2] = -100.0
                        
                        coeff_x = cheb.chebfit(self.time_old_v,
                                                                   np.exp(exponent) * self.f_vec,
                                                                   len(self.time_old_v) - 1)
                        coeff_y = cheb.chebfit(self.time_old_v,
                                                                   np.exp(exponent) * self.g_vec,
                                                                   len(self.time_old_v) - 1)

                        coeffx_int = cheb.chebint(coeff_x)
                        coeffy_int = cheb.chebint(coeff_y)

                        f_tld_x = cheb.chebval(self.time_old_v[-1], coeffx_int) \
                                          - cheb.chebval(self.time_old_v[0], coeffx_int)
                        f_tld_y = cheb.chebval(self.time_old_v[-1], coeffy_int) \
                                          - cheb.chebval(self.time_old_v[0], coeffy_int)
                        
                        self.fx_vector = np.append(self.fx_vector, f_tld_x)
                        self.fy_vector = np.append(self.fy_vector, f_tld_y)
                        
                        f_tld_x_frac = k * self.p.gamma * f_tld_x \
                                                         / ((k * self.p.gamma) ** 2
                                                          + (k ** 2 - self.p.alpha) ** 2)
                        f_tld_y_frac = k * self.p.gamma * f_tld_y \
                                                         / ((k * self.p.gamma) ** 2 
                                                         + (k ** 2 - self.p.alpha) ** 2)
                        
                        f_tld_x_v = np.append(f_tld_x_v, f_tld_x_frac)
                        f_tld_y_v = np.append(f_tld_y_v, f_tld_y_frac)
                        
                self.f_tld_x = f_tld_x_v
                self.f_tld_y = f_tld_y_v

                exponentx = -self.k_v ** 2 * self.dt
                exponentx[exponentx &lt;-1e2] = -100
                resultx_v = np.exp(exponentx) * self.G_v_imag[0] - f_tld_x_v            

                exponenty = -self.k_v ** 2 * self.dt
                exponenty[exponenty &lt;-1e2] = -100
                resulty_v = np.exp(exponenty) * self.G_v_imag[1] - f_tld_y_v
                
                resultx_v[abs(resultx_v) &lt; 1e-15] = 0
                resulty_v[abs(resulty_v) &lt; 1e-15] = 0
                result_v = np.array([resultx_v, resulty_v])             
                self.G_v_imag = result_v
                return result_v
        
        def H(self):
                &#34;&#34;&#34;Calculates H.&#34;&#34;&#34;
                if self.time_vec[0] - self.t0 == 0:
                        self.G_fun()
                else:
                        self.G_update()
                resultx_v = np.array([])
                resulty_v = np.array([])
                
                for jj in range(1, len(self.time_vec)):         
                        exponent = np.log((2 / np.pi) * 2 / (1 - self.k_hat_v) ** 2) \
                                           - (self.time_vec[jj] - self.time_vec[0]) * self.k_v ** 2
                        exponent[exponent &lt; -1e2] = -100

                        Hx_intgrnd = -np.exp(exponent) * self.G_v_imag[0] * self.k_v
                        Hy_intgrnd = -np.exp(exponent) * self.G_v_imag[1] * self.k_v
                        Hx_intgrnd[abs(Hx_intgrnd) &lt; 1e-40] = 0
                        Hy_intgrnd[abs(Hy_intgrnd) &lt; 1e-40] = 0

                        coeff_x = cheb.chebfit(self.k_hat_v, Hx_intgrnd,
                                                                   len(self.k_hat_v) - 1)
                        coeff_y = cheb.chebfit(self.k_hat_v, Hy_intgrnd,
                                                                   len(self.k_hat_v) - 1)
                        coeffx_int = cheb.chebint(coeff_x)
                        coeffy_int = cheb.chebint(coeff_y)

                        resultx_v = np.append(resultx_v, cheb.chebval(1, coeffx_int) \
                                                 - cheb.chebval(-1, coeffx_int))
                        resulty_v = np.append(resulty_v, cheb.chebval(1, coeffy_int) \
                                                 - cheb.chebval(-1, coeffy_int))
                        
                if self.time_vec[0] - self.t0 == 0:
                        resultx_v = np.append(self.qx_x0[0], resultx_v)
                        resulty_v = np.append(self.qy_x0[0], resulty_v)
                else:
                        resultx_v = np.append(self.qx_x0[-1], resultx_v)
                        resulty_v = np.append(self.qy_x0[-1], resulty_v)
                
                result_v   = np.append(resultx_v, resulty_v)
                self.H_v   = result_v
                return resultx_v, resulty_v
        
        def eta(self, q_guess):
                &#34;&#34;&#34;Calculates eta.&#34;&#34;&#34;
                q_v     = np.array([])
                p_v     = np.array([])
                for tt in range(0, len(self.time_vec)):
                        q_v = np.append(q_v, q_guess[tt])
                        p_v = np.append(p_v, q_guess[tt+int(len(q_guess)/2)])
                
                coeff_x = cheb.chebfit(self.time_vec, q_v, len(self.time_vec)-1)
                coeff_y = cheb.chebfit(self.time_vec, p_v, len(self.time_vec)-1)
                intcoeff_x = cheb.chebint(coeff_x)
                intcoeff_y = cheb.chebint(coeff_y)
                value_x_0 = cheb.chebval(self.time_vec[0], intcoeff_x)
                value_y_0 = cheb.chebval(self.time_vec[0], intcoeff_y)
                
                resultx_v = np.array([0])
                resulty_v = np.array([0])
                for tt in range(1, len(self.time_vec)):
                        resultx_v = np.append(resultx_v, cheb.chebval(self.time_vec[tt],
                                                                  intcoeff_x) - value_x_0)
                        resulty_v = np.append(resulty_v, cheb.chebval(self.time_vec[tt],
                                                                  intcoeff_y) - value_y_0)
                
                result_v   = np.append(resultx_v, resulty_v)
                return result_v
        
        def Psi(self, x_guess):
                &#34;&#34;&#34;Calculates psi.&#34;&#34;&#34;
                U_v = np.array([])
                V_v     = np.array([])
                for tt in range(0, len(self.time_vec)):
                        x = x_guess[tt]
                        y = x_guess[tt + int(len(x_guess)/2)]
                        u, v = self.vel.get_velocity(x, y, self.time_vec[tt])
                        U_v = np.append(U_v, u)
                        V_v = np.append(V_v, v)
                
                coeff_x = cheb.chebfit(self.time_vec, U_v, len(self.time_vec)-1)
                coeff_y = cheb.chebfit(self.time_vec, V_v, len(self.time_vec)-1)
                intcoeff_x = cheb.chebint(coeff_x)
                intcoeff_y = cheb.chebint(coeff_y)
                value_x_0 = cheb.chebval(self.time_vec[0], intcoeff_x)
                value_y_0 = cheb.chebval(self.time_vec[0], intcoeff_y)
                
                resultx_v = np.array([0])
                resulty_v = np.array([0])
                for tt in range(1, len(self.time_vec)):
                        resultx_v = np.append(resultx_v, cheb.chebval(self.time_vec[tt],
                                                                  intcoeff_x) - value_x_0)
                        resulty_v = np.append(resulty_v, cheb.chebval(self.time_vec[tt],
                                                                  intcoeff_y) - value_y_0)
                
                result_v = np.append(resultx_v, resulty_v)
                return result_v
        
        def J(self,guess):
                &#34;&#34;&#34;Defines the function J to obtain rules on.&#34;&#34;&#34;
                q_guess = guess[:len(self.time_vec)*2]
                x_guess = guess[len(self.time_vec)*2:]
                
                # Define function J, on which Newton method is used.
                J_v     = q_guess - self.F(q_guess, x_guess) - self.H_v
                Psi_v = self.x0_v - x_guess + self.eta(q_guess) + self.Psi(x_guess)     
                result_v = np.append(J_v, Psi_v)
                return result_v
        
        # Function that runs nonlinear solver and calculates solution at boundary.
        def update(self):
                &#34;&#34;&#34;Updates the velocity and trajectory of the particle.&#34;&#34;&#34;      
                q_guess, p_guess = self.H()     # guess for the relative velocity
                
                if self.time - self.t0 == 0:
                        x_guess = np.array([self.x])
                        y_guess = np.array([self.y])
                else:
                        x_guess = np.array([self.x[-1]])
                        y_guess = np.array([self.y[-1]])
                
                # guess for the position
                for tt in range(0, len(self.time_vec)-1):
                        dt = self.time_vec[tt+1] - self.time_vec[tt]
                        q, p = q_guess[tt], p_guess[tt]
                        u, v = self.vel.get_velocity(x_guess[-1], y_guess[-1],
                                                                                 self.time_vec[tt])
                        x_guess = np.append(x_guess, x_guess[-1] + dt * (q + u))
                        y_guess = np.append(y_guess, y_guess[-1] + dt * (p + v))
                
                vel_guess = np.append(q_guess, p_guess)
                pos_guess = np.append(x_guess, y_guess)
                guess = np.append(vel_guess, pos_guess)
                
                # Newton-Raphson method
                #print(&#34;Initial guess: \n&#34; + str(guess))
                iter_limit = 1000
                tolerance  = 1e-13
                
                try:
                        result = newton(self.J, guess, maxiter=iter_limit, tol=tolerance,
                                                        full_output=True)

                        # Check method converged before reaching maxiter.
                        if any(np.invert(result[1])) == False: # Method converged!
                                solution = result[0]
                        else:
                                raise
                except:
                        try: # Try Newton method with Krylov inverse Jacobian approximation.
                                solution = newton_krylov(self.J, guess, maxiter=iter_limit,
                                                                                 f_tol=tolerance)
                        # If everything failed, use fsolve, which is slower but more stable.
                        except:
                                solution = fsolve(self.J, guess, maxfev=iter_limit,
                                                                  xtol=tolerance)
                
                #print(&#34;G: &#34; + str(self.G_v_imag))
                self.q_x0 = np.copy(solution)
                self.qx_x0 = np.copy(solution[:len(self.time_vec)])
                self.qy_x0 = np.copy(solution[len(self.time_vec): 2*len(self.time_vec)])
                self.x = np.copy(solution[2 * len(self.time_vec): 3*len(self.time_vec)])
                self.y = np.copy(solution[3 * len(self.time_vec):])
                
                #print(&#34;2 norm: \n&#34; + str(np.linalg.norm(self.J(self.q_x0))))
                #print(&#34;Inf norm: \n&#34; + str(np.linalg.norm(self.J(self.q_x0),np.inf)))
                #print(&#34;Method&#39;s convergence: \n&#34; + str(result[1]))
                #print(&#34;Solution: \nq_1: &#34;+str(self.qx_x0)+&#34;\nq_2: &#34;+str(self.qy_x0))
                #assert (not any(np.invert(result[1]))), &#39;Method does not converge!&#39;
                
                pos_vec = np.array([self.x[1:], self.y[1:]])
                q_vec = np.array([self.qx_x0[1:], self.qy_x0[1:]])
                self.pos_vec = np.vstack([self.pos_vec, np.transpose(pos_vec)])
                self.q_vec = np.vstack([self.q_vec, np.transpose(q_vec)])
                
                self.time_old_v = self.time_vec
                self.time += self.dt
                self.interval_def()
                
                return solution</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.F"><code class="name flex">
<span>def <span class="ident">F</span></span>(<span>self, q_guess, x_guess)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates F(t_j).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def F(self, q_guess, x_guess):
        &#34;&#34;&#34;Calculates F(t_j).&#34;&#34;&#34;        
        # Change solution guess according to function f
        f_vec     = np.array([])
        g_vec     = np.array([])
        
        for tt in range(0,len(self.time_vec)):
                q_vec  = np.array([q_guess[tt],
                                                   q_guess[tt + int(len(q_guess) / 2)]])
                x_vec  = np.array([x_guess[tt],
                                                   x_guess[tt + int(len(x_guess) / 2)]])
                f, g   = self.calculate_f()
                f_vec  = np.append(f_vec, f)
                g_vec  = np.append(g_vec, g)
        
        self.f_vec = f_vec
        self.g_vec = g_vec
        
        # Approximate by Chebyshev coeff
        coeff_x = cheb.chebfit(self.time_vec-self.time_vec[0],
                                                   f_vec, len(self.time_vec)-1)
        coeff_y = cheb.chebfit(self.time_vec-self.time_vec[0],
                                                   g_vec, len(self.time_vec)-1)
        
        # Obtain F as the dot product of the coeff times the matrix entries
        result_x   = np.array([])
        result_y   = np.array([])
        for jj in range(0,len(self.time_vec)):
                result_x  = np.append(result_x, (2.0/np.pi) \
                                                          * np.dot(coeff_x, self.M[jj]))
                result_y  = np.append(result_y, (2.0/np.pi) \
                                                          * np.dot(coeff_y, self.M[jj]))
        
        result_v = np.append(result_x, result_y)
        return result_v</code></pre>
</details>
</dd>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.G_fun"><code class="name flex">
<span>def <span class="ident">G_fun</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates G.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def G_fun(self):
        &#34;&#34;&#34;Calculates G.&#34;&#34;&#34;     
        resultx_v = np.array([])
        resulty_v = np.array([])

        for k in self.k_v:
                q_hat = self.q_hat(k)
                fun_num_x  = (1j * k * self.p.gamma - (k ** 2 - self.p.alpha)) \
                                                 * (self.p.gamma * q_hat[0] + self.qx_x0[0])
                fun_num_y  = (1j * k * self.p.gamma - (k ** 2 - self.p.alpha)) \
                                                 * (self.p.gamma * q_hat[1] + self.qy_x0[0])
                fun_den = - (k * self.p.gamma) ** 2 - (k ** 2 - self.p.alpha) ** 2
                resultx_v  = np.append(resultx_v, fun_num_x / fun_den)
                resulty_v  = np.append(resulty_v, fun_num_y / fun_den)
        
        result_v = np.array([resultx_v, resulty_v])             
        self.G_v_imag = result_v.imag
        return result_v.imag</code></pre>
</details>
</dd>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.G_update"><code class="name flex">
<span>def <span class="ident">G_update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the term G.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def G_update(self):
        &#34;&#34;&#34;Updates the term G.&#34;&#34;&#34;
        #f_vec = np.array([[],[]])
        f_tld_x_v = np.array([])
        f_tld_y_v = np.array([])
        self.fx_vector = np.array([])
        self.fy_vector = np.array([])
        
        for k in self.k_v:
                # Approximate by Chebyshev coeff
                exponent = -(self.time_old_v[-1] - self.time_old_v) * k ** 2
                exponent[exponent &lt; -1e2] = -100.0
                
                coeff_x = cheb.chebfit(self.time_old_v,
                                                           np.exp(exponent) * self.f_vec,
                                                           len(self.time_old_v) - 1)
                coeff_y = cheb.chebfit(self.time_old_v,
                                                           np.exp(exponent) * self.g_vec,
                                                           len(self.time_old_v) - 1)

                coeffx_int = cheb.chebint(coeff_x)
                coeffy_int = cheb.chebint(coeff_y)

                f_tld_x = cheb.chebval(self.time_old_v[-1], coeffx_int) \
                                  - cheb.chebval(self.time_old_v[0], coeffx_int)
                f_tld_y = cheb.chebval(self.time_old_v[-1], coeffy_int) \
                                  - cheb.chebval(self.time_old_v[0], coeffy_int)
                
                self.fx_vector = np.append(self.fx_vector, f_tld_x)
                self.fy_vector = np.append(self.fy_vector, f_tld_y)
                
                f_tld_x_frac = k * self.p.gamma * f_tld_x \
                                                 / ((k * self.p.gamma) ** 2
                                                  + (k ** 2 - self.p.alpha) ** 2)
                f_tld_y_frac = k * self.p.gamma * f_tld_y \
                                                 / ((k * self.p.gamma) ** 2 
                                                 + (k ** 2 - self.p.alpha) ** 2)
                
                f_tld_x_v = np.append(f_tld_x_v, f_tld_x_frac)
                f_tld_y_v = np.append(f_tld_y_v, f_tld_y_frac)
                
        self.f_tld_x = f_tld_x_v
        self.f_tld_y = f_tld_y_v

        exponentx = -self.k_v ** 2 * self.dt
        exponentx[exponentx &lt;-1e2] = -100
        resultx_v = np.exp(exponentx) * self.G_v_imag[0] - f_tld_x_v            

        exponenty = -self.k_v ** 2 * self.dt
        exponenty[exponenty &lt;-1e2] = -100
        resulty_v = np.exp(exponenty) * self.G_v_imag[1] - f_tld_y_v
        
        resultx_v[abs(resultx_v) &lt; 1e-15] = 0
        resulty_v[abs(resulty_v) &lt; 1e-15] = 0
        result_v = np.array([resultx_v, resulty_v])             
        self.G_v_imag = result_v
        return result_v</code></pre>
</details>
</dd>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.H"><code class="name flex">
<span>def <span class="ident">H</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates H.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def H(self):
        &#34;&#34;&#34;Calculates H.&#34;&#34;&#34;
        if self.time_vec[0] - self.t0 == 0:
                self.G_fun()
        else:
                self.G_update()
        resultx_v = np.array([])
        resulty_v = np.array([])
        
        for jj in range(1, len(self.time_vec)):         
                exponent = np.log((2 / np.pi) * 2 / (1 - self.k_hat_v) ** 2) \
                                   - (self.time_vec[jj] - self.time_vec[0]) * self.k_v ** 2
                exponent[exponent &lt; -1e2] = -100

                Hx_intgrnd = -np.exp(exponent) * self.G_v_imag[0] * self.k_v
                Hy_intgrnd = -np.exp(exponent) * self.G_v_imag[1] * self.k_v
                Hx_intgrnd[abs(Hx_intgrnd) &lt; 1e-40] = 0
                Hy_intgrnd[abs(Hy_intgrnd) &lt; 1e-40] = 0

                coeff_x = cheb.chebfit(self.k_hat_v, Hx_intgrnd,
                                                           len(self.k_hat_v) - 1)
                coeff_y = cheb.chebfit(self.k_hat_v, Hy_intgrnd,
                                                           len(self.k_hat_v) - 1)
                coeffx_int = cheb.chebint(coeff_x)
                coeffy_int = cheb.chebint(coeff_y)

                resultx_v = np.append(resultx_v, cheb.chebval(1, coeffx_int) \
                                         - cheb.chebval(-1, coeffx_int))
                resulty_v = np.append(resulty_v, cheb.chebval(1, coeffy_int) \
                                         - cheb.chebval(-1, coeffy_int))
                
        if self.time_vec[0] - self.t0 == 0:
                resultx_v = np.append(self.qx_x0[0], resultx_v)
                resulty_v = np.append(self.qy_x0[0], resulty_v)
        else:
                resultx_v = np.append(self.qx_x0[-1], resultx_v)
                resulty_v = np.append(self.qy_x0[-1], resulty_v)
        
        result_v   = np.append(resultx_v, resulty_v)
        self.H_v   = result_v
        return resultx_v, resulty_v</code></pre>
</details>
</dd>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.J"><code class="name flex">
<span>def <span class="ident">J</span></span>(<span>self, guess)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the function J to obtain rules on.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def J(self,guess):
        &#34;&#34;&#34;Defines the function J to obtain rules on.&#34;&#34;&#34;
        q_guess = guess[:len(self.time_vec)*2]
        x_guess = guess[len(self.time_vec)*2:]
        
        # Define function J, on which Newton method is used.
        J_v     = q_guess - self.F(q_guess, x_guess) - self.H_v
        Psi_v = self.x0_v - x_guess + self.eta(q_guess) + self.Psi(x_guess)     
        result_v = np.append(J_v, Psi_v)
        return result_v</code></pre>
</details>
</dd>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.Lm"><code class="name flex">
<span>def <span class="ident">Lm</span></span>(<span>self, m)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates L(m) function,
<span><span class="MathJax_Preview">\mathcal{L}(m) = \int_0^{\infty}
\frac{k^2 \gamma e^{-k^2 m}}{k^2 \gamma^2 + (k^2 - \alpha)^2} dk,</span><script type="math/tex; mode=display">\mathcal{L}(m) = \int_0^{\infty}
\frac{k^2 \gamma e^{-k^2 m}}{k^2 \gamma^2 + (k^2 - \alpha)^2} dk,</script></span>
used to obtain matrix M and then F.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Lm(self, m):
        r&#34;&#34;&#34;
        Calculates L(m) function,
        $$\mathcal{L}(m) = \int_0^{\infty}
        \frac{k^2 \gamma e^{-k^2 m}}{k^2 \gamma^2 + (k^2 - \alpha)^2} dk,$$
        used to obtain matrix M and then F.
        &#34;&#34;&#34;     
        fun_exp = lambda k: np.exp(-m * k ** 2)
        fun_frac = lambda k: self.p.gamma * k ** 2 / \
                           ((k * self.p.gamma) ** 2 + (k ** 2 - self.p.alpha) ** 2)     
        fun = lambda k: fun_exp(k) * fun_frac(k)
        fun_v = np.array([])

        for kk in range(0, len(self.k_v)):
                fun_v = np.append(fun_v, fun(self.k_v[kk]))
        
        coeff = cheb.chebfit(self.k_hat_v, fun_v, len(self.k_v) - 1)
        coeff_int = cheb.chebint(coeff)
        result = cheb.chebval(1, coeff_int) - cheb.chebval(-1, coeff_int)
        return result</code></pre>
</details>
</dd>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.M_nn"><code class="name flex">
<span>def <span class="ident">M_nn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates matrix M.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def M_nn(self):
        &#34;&#34;&#34;Calculates matrix M.&#34;&#34;&#34;
        name_file = &#39;a00_MATRX_VALUES.txt&#39;
        
        if exists(name_file) == True:
                with open(name_file, &#39;rb&#39;) as file:
                        mat = np.load(file)
        
        if exists(name_file) == False or mat.shape[0] != len(self.time_vec):
                #print(&#39;Creating Matrix.&#39;)
                time.sleep(0.3)
                #time1   = time.time()
                mat      = np.zeros([len(self.time_vec),len(self.time_vec)])
        
                for ii in progressbar(range(1,len(self.time_vec))):
                        for nn in range(0,len(self.time_vec)):
                                # Create vector of coeffs to define Chebyshev polynomial
                                coeff     = np.zeros([1,len(self.time_vec)])[0]

                                # Fill in the element of the vector corresponding to the
                                # matrix entry
                                coeff[nn]  = 1
                                poly = cheb.Chebyshev(coeff) # change into Cheb polynomial

                                # Create function of full integrand of the matrix element
                                fun     = lambda s: poly(s) * self.Lm(self.time_vec[ii]-s)
                                aux = quad(fun, self.time_vec[0], self.time_vec[ii],
                                                   epsrel=1e-9, epsabs=1e-9, limit=1000,
                                                   points=[self.time_vec[ii]]) # integrate
                                mat[ii][nn] = aux[0] # fill in matrix

                                # Display values
                                #print(&#39;position [t_&#39;,ii,&#39;, T_&#39;,nn,&#39;]:&#39;,mat[ii][nn])
                                #print(&#39;error:&#39;,aux[1])
        
                with open(name_file, &#39;wb&#39;) as file:
                        np.save(file, mat)
                
        self.M = mat
        #time2 = time.time()
        #print(&#34;Time to calculate Matrix: &#34; + str(time2-time1))</code></pre>
</details>
</dd>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.Psi"><code class="name flex">
<span>def <span class="ident">Psi</span></span>(<span>self, x_guess)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates psi.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Psi(self, x_guess):
        &#34;&#34;&#34;Calculates psi.&#34;&#34;&#34;
        U_v = np.array([])
        V_v     = np.array([])
        for tt in range(0, len(self.time_vec)):
                x = x_guess[tt]
                y = x_guess[tt + int(len(x_guess)/2)]
                u, v = self.vel.get_velocity(x, y, self.time_vec[tt])
                U_v = np.append(U_v, u)
                V_v = np.append(V_v, v)
        
        coeff_x = cheb.chebfit(self.time_vec, U_v, len(self.time_vec)-1)
        coeff_y = cheb.chebfit(self.time_vec, V_v, len(self.time_vec)-1)
        intcoeff_x = cheb.chebint(coeff_x)
        intcoeff_y = cheb.chebint(coeff_y)
        value_x_0 = cheb.chebval(self.time_vec[0], intcoeff_x)
        value_y_0 = cheb.chebval(self.time_vec[0], intcoeff_y)
        
        resultx_v = np.array([0])
        resulty_v = np.array([0])
        for tt in range(1, len(self.time_vec)):
                resultx_v = np.append(resultx_v, cheb.chebval(self.time_vec[tt],
                                                          intcoeff_x) - value_x_0)
                resulty_v = np.append(resulty_v, cheb.chebval(self.time_vec[tt],
                                                          intcoeff_y) - value_y_0)
        
        result_v = np.append(resultx_v, resulty_v)
        return result_v</code></pre>
</details>
</dd>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.calculate_f"><code class="name flex">
<span>def <span class="ident">calculate_f</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Define forcing function f(q(0, t)). This will differ for different
boundary problems.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_f(self):
        &#34;&#34;&#34;
        Define forcing function f(q(0, t)). This will differ for different 
        boundary problems.
        &#34;&#34;&#34;
        return 0, self.p.sigma</code></pre>
</details>
</dd>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.eta"><code class="name flex">
<span>def <span class="ident">eta</span></span>(<span>self, q_guess)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates eta.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eta(self, q_guess):
        &#34;&#34;&#34;Calculates eta.&#34;&#34;&#34;
        q_v     = np.array([])
        p_v     = np.array([])
        for tt in range(0, len(self.time_vec)):
                q_v = np.append(q_v, q_guess[tt])
                p_v = np.append(p_v, q_guess[tt+int(len(q_guess)/2)])
        
        coeff_x = cheb.chebfit(self.time_vec, q_v, len(self.time_vec)-1)
        coeff_y = cheb.chebfit(self.time_vec, p_v, len(self.time_vec)-1)
        intcoeff_x = cheb.chebint(coeff_x)
        intcoeff_y = cheb.chebint(coeff_y)
        value_x_0 = cheb.chebval(self.time_vec[0], intcoeff_x)
        value_y_0 = cheb.chebval(self.time_vec[0], intcoeff_y)
        
        resultx_v = np.array([0])
        resulty_v = np.array([0])
        for tt in range(1, len(self.time_vec)):
                resultx_v = np.append(resultx_v, cheb.chebval(self.time_vec[tt],
                                                          intcoeff_x) - value_x_0)
                resulty_v = np.append(resulty_v, cheb.chebval(self.time_vec[tt],
                                                          intcoeff_y) - value_y_0)
        
        result_v   = np.append(resultx_v, resulty_v)
        return result_v</code></pre>
</details>
</dd>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.interval_def"><code class="name flex">
<span>def <span class="ident">interval_def</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines chebyshev nodes in time subdomain [t_i, ti + dt],
i.e. s_1, s_2, &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interval_def(self):
        &#34;&#34;&#34;
        Defines chebyshev nodes in time subdomain [t_i, ti + dt], 
        i.e. s_1, s_2, ...
        &#34;&#34;&#34;
        self.time_vec = np.array([])
        x = np.array([])
        y = np.array([])
        for jj in range(0, self.time_nodes):
                self.time_vec  = np.append(self.time_vec, self.time + 0.5 \
                                                                   * self.dt * (1 - np.cos(jj * np.pi 
                                                                   / (self.time_nodes - 1))))
                if self.time - self.t0 == 0:
                        x = np.append(x, self.x)
                        y = np.append(y, self.y)
                else:
                        x = np.append(x, self.x[-1])
                        y = np.append(y, self.y[-1])
        self.x0_v = np.append(x, y)</code></pre>
</details>
</dd>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.q_hat"><code class="name flex">
<span>def <span class="ident">q_hat</span></span>(<span>self, k)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates q hat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def q_hat(self, k):
        &#34;&#34;&#34;Calculates q hat&#34;&#34;&#34;     
        intgnd_x = np.exp(1j * k * self.z_v) * self.qx_tj * 2 \
                                                 / (1 - self.z_hat_v) ** 2
        intgnd_y = np.exp(1j * k * self.z_v) * self.qy_tj * 2 \
                                                 / (1 - self.z_hat_v) ** 2
        
        coeff_x = cheb.chebfit(self.z_hat_v, intgnd_x, len(self.z_hat_v) - 1)
        coeff_y = cheb.chebfit(self.z_hat_v, intgnd_y, len(self.z_hat_v) - 1)
        coeffx_int = cheb.chebint(coeff_x)
        coeffy_int = cheb.chebint(coeff_y)      
        result_x = cheb.chebval(1, coeffx_int) - cheb.chebval(-1, coeffx_int)
        result_y = cheb.chebval(1, coeffy_int) - cheb.chebval(-1, coeffy_int)
        result   = np.array([[result_x], [result_y]])
        return result</code></pre>
</details>
</dd>
<dt id="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the velocity and trajectory of the particle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
        &#34;&#34;&#34;Updates the velocity and trajectory of the particle.&#34;&#34;&#34;      
        q_guess, p_guess = self.H()     # guess for the relative velocity
        
        if self.time - self.t0 == 0:
                x_guess = np.array([self.x])
                y_guess = np.array([self.y])
        else:
                x_guess = np.array([self.x[-1]])
                y_guess = np.array([self.y[-1]])
        
        # guess for the position
        for tt in range(0, len(self.time_vec)-1):
                dt = self.time_vec[tt+1] - self.time_vec[tt]
                q, p = q_guess[tt], p_guess[tt]
                u, v = self.vel.get_velocity(x_guess[-1], y_guess[-1],
                                                                         self.time_vec[tt])
                x_guess = np.append(x_guess, x_guess[-1] + dt * (q + u))
                y_guess = np.append(y_guess, y_guess[-1] + dt * (p + v))
        
        vel_guess = np.append(q_guess, p_guess)
        pos_guess = np.append(x_guess, y_guess)
        guess = np.append(vel_guess, pos_guess)
        
        # Newton-Raphson method
        #print(&#34;Initial guess: \n&#34; + str(guess))
        iter_limit = 1000
        tolerance  = 1e-13
        
        try:
                result = newton(self.J, guess, maxiter=iter_limit, tol=tolerance,
                                                full_output=True)

                # Check method converged before reaching maxiter.
                if any(np.invert(result[1])) == False: # Method converged!
                        solution = result[0]
                else:
                        raise
        except:
                try: # Try Newton method with Krylov inverse Jacobian approximation.
                        solution = newton_krylov(self.J, guess, maxiter=iter_limit,
                                                                         f_tol=tolerance)
                # If everything failed, use fsolve, which is slower but more stable.
                except:
                        solution = fsolve(self.J, guess, maxfev=iter_limit,
                                                          xtol=tolerance)
        
        #print(&#34;G: &#34; + str(self.G_v_imag))
        self.q_x0 = np.copy(solution)
        self.qx_x0 = np.copy(solution[:len(self.time_vec)])
        self.qy_x0 = np.copy(solution[len(self.time_vec): 2*len(self.time_vec)])
        self.x = np.copy(solution[2 * len(self.time_vec): 3*len(self.time_vec)])
        self.y = np.copy(solution[3 * len(self.time_vec):])
        
        #print(&#34;2 norm: \n&#34; + str(np.linalg.norm(self.J(self.q_x0))))
        #print(&#34;Inf norm: \n&#34; + str(np.linalg.norm(self.J(self.q_x0),np.inf)))
        #print(&#34;Method&#39;s convergence: \n&#34; + str(result[1]))
        #print(&#34;Solution: \nq_1: &#34;+str(self.qx_x0)+&#34;\nq_2: &#34;+str(self.qy_x0))
        #assert (not any(np.invert(result[1]))), &#39;Method does not converge!&#39;
        
        pos_vec = np.array([self.x[1:], self.y[1:]])
        q_vec = np.array([self.qx_x0[1:], self.qy_x0[1:]])
        self.pos_vec = np.vstack([self.pos_vec, np.transpose(pos_vec)])
        self.q_vec = np.vstack([self.q_vec, np.transpose(q_vec)])
        
        self.time_old_v = self.time_vec
        self.time += self.dt
        self.interval_def()
        
        return solution</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle" href="index.html">modelling-microplastics-transport.examples.sedimenting_particle</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas">MaxeyRileyFokas</a></code></h4>
<ul class="two-column">
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.F" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.F">F</a></code></li>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.G_fun" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.G_fun">G_fun</a></code></li>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.G_update" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.G_update">G_update</a></code></li>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.H" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.H">H</a></code></li>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.J" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.J">J</a></code></li>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.Lm" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.Lm">Lm</a></code></li>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.M_nn" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.M_nn">M_nn</a></code></li>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.Psi" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.Psi">Psi</a></code></li>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.calculate_f" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.calculate_f">calculate_f</a></code></li>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.eta" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.eta">eta</a></code></li>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.interval_def" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.interval_def">interval_def</a></code></li>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.q_hat" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.q_hat">q_hat</a></code></li>
<li><code><a title="modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.update" href="#modelling-microplastics-transport.examples.sedimenting_particle.a09_PRTCLE_FOKAS.MaxeyRileyFokas.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>